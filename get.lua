-- get.lua
-- Implements the /get command.

-- Table to store a blacklist of items.
local ItemBlackList = {}

local CommandUsage = "Usage: %s %s"
local GetCommandUsageTail = "<item> [amount] [data] [datatag]"

local MessagePlayerFailure = "Couldn't find that player."
local MessageAmountFailure = "Couldn't get you an amount over the limit of 64."
local MessageItemNameFailure = "Couldn't find that item."
local MessageDataTagFailure = "Couldn't quantify that data: "
local MessageUnknownError = "Couldn't get you that item."
local MessageGiveSuccessful = "Got you some %s (%d)."
local MessageBadAmount = "Couldn't get you a non-numeric amount."
local MessageBadData = "Couldn't quantify non-numeric data."

local UnbalancedCurleyBracesFailure = "Couldn't parse because you're missing curlies."
local UnbalancedSquareBracketsFailure = "Couldn't parse because you're missing brackets."
local StartWithBraceFailure = "Couldn't parse because you're missing curlies."
local EndWithBraceFailure = "Couldn't parse because you're missing curlies."

local BlackListHeaderComment = "# Contains the list of items that cannot be obtained through the get command.\n"
local BlackListHeaderComment2 = "# Add items to this file to add them to the blacklist.\n"
local BlackListHeaderComment3 = "# Generated by the pluginset.\n"
local BlackListFileName = "itemblacklist"
local BlackListFileCreationError = "%s: Could not create the file: %s"

local MaxNumberOfItems = 64

local function SplitDataTag(DataTag)
	local Sandbox = {}
	local SavedStrings = {}

	local function PreserveString(StringToSave)
		table.insert(SavedStrings, StringToSave)
		return "\"%s" .. table.getn(SavedStrings) .. "\""
    end
    
	local function HandleUnquotedString(StringToFix)
		StringToFix = string.gsub(StringToFix, ",", "\",\"")
		return ":[" .. PreserveString(StringToFix) .. "]"
	end
    
	local function VerifyDataTagFormat()
		-- Make sure the string is surrounded by curlies.
		if string.sub(DataTag, 1, 1) ~= "{" then
			return nil, StartWithBraceFailure
		end
		if string.sub(DataTag, -1, -1) ~= "}" then
			return nil, EndWithBraceFailure
		end

		-- Check for balanced curlies and brackets.
		local FirstLoc, LastLoc = string.find(DataTag, "%b{}")
		if FirstLoc ~= 1 or LastLoc ~= string.len( DataTag ) then
			return nil, UnbalancedCurleyBracesFailure
		end

		local DataTagLen = string.len(DataTag)
        FirstLoc, LastLoc = string.find(DataTag, "%b[]")
        
		if FirstLoc and LastLoc then
			local FirstBrace = math.min(string.find(DataTag, "%[") or DataTagLen, string.find(DataTag, "%]") or DataTagLen)
			local LastBrace = math.max(string.find(DataTag, "%[", LastLoc + 1) or 0, string.find(DataTag, "%]", LastLoc + 1) or 0)

			-- Loop over the string and make sure we've found all the brackets.
			while LastLoc < LastBrace do
				local _, Tmp = string.find(DataTag, "%b[]", LastLoc + 1)
				if not Tmp then
					break
				end
				LastLoc = Tmp
				Tmp = math.max( string.find(DataTag, "%[", LastLoc + 1) or 0, string.find(DataTag, "%]", LastLoc + 1) or 0)
				if Tmp and Tmp > LastBrace then
					LastBrace = Tmp
				end
			end

			if (FirstLoc > FirstBrace) or (LastLoc < LastBrace) then
				return nil, UnbalancedSquareBracketsFailure
			end
		end
		return true
    end
    
    -- Preserve the string before making corrections.
    DataTag = string.gsub(DataTag, "\"([^\"]+)\"", PreserveString)

    -- Handles unquoted strings for vanilla compatibility.
    DataTag = string.gsub(DataTag, ":%s-%[%s-([^{\"%s][^%]]+[^\"])%]", HandleUnquotedString)

	local Success, errMsg = VerifyDataTagFormat()
	if not Success then
		return nil, errMsg
    end
    
    -- Let's turn the vanilla format into a table.
    DataTag = string.gsub(DataTag, ":", "=")
	DataTag = string.gsub(DataTag, "%[", "{")
	DataTag = string.gsub(DataTag, "%]", "}")

    for index, value in ipairs(SavedStrings) do
		DataTag = string.gsub(DataTag, "%%s" .. index, value)
    end
	local DataTagFunc, err = loadstring("dt = " .. DataTag)
	if not DataTagFunc then
		return nil, err
	end
	setfenv(DataTagFunc, Sandbox)
	-- This could be done better; let's fix that sometime.
	local Success, errMsg = pcall(DataTagFunc)
	if not Success then
		return nil, errMsg
    end
    return Sandbox.dt, nil
end

local function GiveItemCommand(Split, Player, SafeCommand)
	local PlayerName = Split[2]
	local lcPlayerName = string.lower(PlayerName or "")
	local ItemName = Split[3]
	local Amount = tonumber(Split[4]) or 1
	local DataValue = tonumber(Split[5]) or 0

	if not PlayerName or not ItemName or Amount < 1 or DataValue < 0 then
		return false
	end

	-- Make sure the amount is numeric.
	if Split[4] and not tonumber(Split[4]) then
		if Player then
			SendMessage(Player, cChatColor.LightGray .. MessageBadAmount)
		else
			LOG(MessageBadAmount)
		end
		return true
	end

	-- Make sure the data value, if any, is numeric.
	if Split[5] and not tonumber(Split[5]) then
		if Player then
			SendMessage(Player, cChatColor.LightGray .. MessageBadData)
		else
			LOG(MessageBadData)
		end
		return true
	end

	-- Get this item and check for validity.
	local Item = cItem()
	local FoundItem = StringToItem(ItemName .. (DataValue ~= 0 and ( ":" .. DataValue) or ""), Item)
	if not IsValidItem(Item.m_ItemType) then
		FoundItem = false
	end

	-- Is this item on the blacklist?
	local function CheckUnSafeItem()
		if not SafeCommand then
		    return false
		end
		return ItemBlackList[Item.m_ItemType] 
	end

	if CheckUnSafeItem() then
		FoundItem = false
	end

	-- Does this item exist?
	if not FoundItem then
		local Message = string.format(MessageItemNameFailure, ItemName)
		if Player then
			SendMessage(Player, cChatColor.LightGray .. Message)
		else
			LOG(Message)
		end
		return true
	end

	-- Process the data value information.
	if Split[6] then
		local DataTagTable, errMsg = SplitDataTag(table.concat(Split, " ", 6 ))
		if not DataTagTable then
			local Message = string.format("%s%s", MessageDataTagFailure, errMsg or MessageUnknownError)
			if Player then
				SendMessage(Player, cChatColor.LightGray .. Message)
			else
				LOG(Message)
			end
			return true
		end

		if DataTagTable.display then
			if DataTagTable.display.Name then
				Item.m_CustomName = DataTagTable.display.Name
			end
			if DataTagTable.display.Lore then
				Item.m_LoreTable = DataTagTable.display.Lore
			end
		end

		if DataTagTable.ench and cItem:IsEnchantable(Item.m_ItemType, true) then
			for _, enchants in ipairs(DataTagTable.ench) do
				Item.m_Enchantments:SetLevel(enchants.id,enchants.lvl)
			end
		end
	end

	-- Respect the item limit (MaxNumberOfItems).
	if Amount > MaxNumberOfItems then
		local Message = string.format(MessageAmountFailure, Amount)
		if Player then
			SendMessage(Player, cChatColor.LightGray .. Message)
		else
			LOG(Message)
		end
		return true
	end

	local function giveItems(NewPlayer)
		if string.lower(NewPlayer:GetName()) ~= lcPlayerName then
			return false
		end
		Item:AddCount(Amount - 1)
        NewPlayer:GetInventory():AddItem(Item)
		local MessageHead = string.format(MessageGiveSuccessful, ((Item.m_CustomName ~= "") and Item.m_CustomName or ItemToString(Item)), Amount)
		-- local MessageTail = " to " .. NewPlayer:GetName()
		SendMessage(NewPlayer, cChatColor.LightGray .. MessageHead)
		-- if Player and NewPlayer:GetName() ~= Player:GetName() then
		-- 	SendMessageSuccess( Player, MessageHead .. MessageTail )
		-- end
		LOG(Player .. ": " .. MessageHead) -- .. MessageTail )
		return true
	end

	-- Finally give the items to the player.
	-- Check to make sure that giving items was successful.
	if not cRoot:Get():FindAndDoWithPlayer(PlayerName, giveItems) then
		if Player then
			SendMessage(Player, cChatColor.LightGray .. MessagePlayerFailure)
		else
			LOG(MessagePlayerFailure)
		end
	end
	return true
end

function HandleGetCommand(Split, Player)
	table.insert(Split, 2, Player:GetName())
	if not GiveItemCommand(Split, Player, true) then
		local Message = string.format(CommandUsage, Split[1] , GetCommandUsageTail)
		SendMessage(Player, cChatColor.LightGray .. Message)
    end
	return true
end

function IntializeItemBlacklist(Plugin)
	-- By default, don't let players obtain piston extensions and moved_block.
	local DefaultBlackList =
	{
		[E_BLOCK_PISTON_EXTENSION]          = true,
		[E_BLOCK_PISTON_MOVED_BLOCK]        = true,
	}

	-- Try to open the file.
	local ItemBlackListFile, ErrMsg = io.open(BlackListFileName, "rb")

	if ItemBlackListFile then
		-- If it exists, read it.
		for value in ItemBlackListFile:lines() do
			value = string.gsub( value, "#+%s-.*", "" )

			local TempItem = cItem()
			local Success = StringToItem( value, TempItem )

			if Success and IsValidItem( TempItem.m_ItemType ) then
				ItemBlackList[TempItem.m_ItemType] = true
			end
		end
		ItemBlackListFile:close()
	else

		-- If it doesn't exist, let's make one.
		ItemBlackListFile, ErrMsg = io.open(BlackListFileName, "wb")
		if ItemBlackListFile then
			ItemBlackListFile:write(BlackListHeaderComment, BlackListHeaderComment2, BlackListHeaderComment3, "\n\n")
			for index, _ in pairs(DefaultBlackList) do
				ItemBlackListFile:write(ItemTypeToString(index), "\n")
			end
			ItemBlackListFile:flush()
			ItemBlackListFile:close()
		else
			-- If it can't be created...
			LOG(string.format(BlackListFileCreationError, Plugin:GetName(), BlackListFileName, (ErrMsg or MessageUnknownError)))
		end
		ItemBlackList = DefaultBlackList
	end
	return true
end